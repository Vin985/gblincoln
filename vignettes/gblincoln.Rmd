---
title: "Introduction to the gblincoln package"
output: rmarkdown::html_vignette
description: >
  This is an introduction to the gblincoln package to calculate Lincoln
  population abundance estimates using banding data recovered from the Gamebirds
  database. 
vignette: >
  %\VignetteIndexEntry{gblincoln}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
library(gblincoln)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Goal of this vignette

This vignette aims to give an overview of how to use the `gblincoln` package
by:

  * [Explaining concepts](#basic-concepts-regarding-lincoln-estimations) 
  surrounding Lincoln estimation
  * [Providing a quick example](#quick-start) to show how to calculate Lincoln
  estimates for a population of Atlantic brants (ATBR) using harvest data
  gathered in the United States.
  * [Describing how to perform each task](#package-description) with the package
  * [Providing additional information](#additional-information) about the package


## Package requirements

This package depends on the `tidyverse` and `ggplot2` libraries.

## Basic concepts regarding Lincoln estimations

Lincoln estimates are calculated by using the number of banded birds and the
number of recovered bands from hunting for a given year and species.
Coupled with a probability of reporting the band data for that year, this allows
us to estimate a harvest rate for that year. This rate is then applied to 
harvest numbers for that year and species to give an estimate of population
abundance. The principles and equations used in this package are described in
Alisauskas *et al.*, (2014)

### Data requirements

Data from four (4) sources are required to perform the estimations:

 * Banding data
 * Recovery data of banded birds
 * Probability of reporting banding information from recovered birds
 * Harvest data


### Actions performed

The main workflow for calculating Lincoln estimates for a given species is 
as follows:

 * Load and clean datasets to make sure they are consistent with one another
 * Filter the banding and recoveries datasets for the population of interest
 * Calculate the number of direct recoveries for each year
 * Estimate the harvest rate
 * Calculate the Lincoln estimates for that population
 

## Quick start

This section provides a quick example on how to use the `gblincoln` package.
More information on how each task works can be found by clicking on each section.

Note that all relevant code portions of this example can
be found in the `ATBR_example.R` file found at the root of the package.

For this example, we will be using datasets provided with the package. For more 
detailed information about these datasets please see 
[this section](#provided-datasets). 
 
Therefore to load the example data, all that is required is to load the package.
To load your own data, please read [this section](#loading-data)

```{r setup}
# Clean environment and load the package
rm(list=ls())
library(gblincoln)

```

We need to [create filters](#creating-filters) to filter our database. All filter
names can be either [column names](#columns-names) from the Gamebirds database,
or the corresponding renamed columns as found in the `gb_colnames` object. Please
see the Gamebirds documentation to know what each column contains.

For our example, we will look into data of the ATBR species, banded in
Nunavut and shot in the United States in the flyway 1 between 2000 and 2019.
(Note: if you need more information about location and flyways available for a given species
please see [this section](#species-locations))
Also keep in mind that [default](#default-filters), are automatically applied
and can be seen in the `DEFAULT_LINCOLN_FILTERS` object.


```{r}
filters_ATBR <-
  list(
    SPEC = "ATBR",
    b.state_name = "Nunavut",
    e.country_code = 'US',
    r.flyway_code = 1,
    b.year= 2000:2019,
    r.corrected_year=2000:2019
  )
```

Then, the quickest way to calculate the estimates is by calling the
`get_lincoln_estimates()` function:

```{r}
lincoln_estimates <-
  get_lincoln_estimates(
    filters = filters_ATBR,
    banding_df = gb_ATBR_banding,
    recoveries_df = gb_ATBR_recoveries,
    harvest_df = gb_ATBR_harvest,
    rho_df = gb_reporting_probas
  )
lincoln_estimates
```


If you prefer to perform every step manually you can do the following:

[Get direct recoveries](#get-direct-recoveries) (this function actually 
[filters the databases](#filtering-the-databases))

```{r}
dr_df <-
  get_direct_recoveries(banding_df = gb_ATBR_banding,
                        recoveries_df = gb_ATBR_recoveries,
                        filters = filters_ATBR)
```


[Get the harvest_rate](#get_harvest_rate)
```{r}
hr_df <- get_harvest_rate(df = dr_df, rho_df = gb_reporting_probas)
```
 
 
[Calculate the Lincoln estimates](#calculate-lincoln-estimates)
```{r}
get_lincoln_estimates(df = hr_df, harvest_df = gb_ATBR_harvest)
```
 
## Package description

The `gblincoln` package aims to calculate Lincoln estimates for population abundance 
using banding data extracted from the Gamebirds database provided by the
**US Banding service**.
The gblincoln package offers functions to perform all steps required to calculate
Lincoln estimates as described in the previous section. In addition, the 
package offers convenience functions for:

 * Comparing multiple filters (e.g. bands with geolocators or not)
 * Listing all availables areas for a given species of birds
 * Plotting comparisons
 * Plotting abundance estimates
 
Since deciding which harvest data to use can be very dependent of the
populations and species studied, this package only performs estimations for
one species at a time. To perform multiple estimations, multiple filters
should be defined and executed one at a time.

### Loading data

All datasets should be loaded using  the **`load_dataset()`** function.
This function performs the following:

 * Load a csv file
 * Rename the columns to ensure consistency between datasets. For more
  information about column renaming, please refer to [this section](#column-names)
 * Classify the age of the birds in two classes: Hatch year (HY) and after hatch
  year (AHY) (Only for banding and recovery data)
 * Correct the recovery year to account for hunting season (recovery data only).
 [Click here](#recovery-year-correction) for more details.
 * Ensure sex classes are properly defined (only banding and recovery data)

If the data to be loaded is not in a csv format, it is possible to load the data
using the appropriate method and then call the **`clean_dataset()`** function on the
resulting dataframe.
The type of action taken during cleaning is determined automatically by the columns present
in the dataset. Please see the help page of the `clean_dataset()` function for
further explanations.

To load a csv file from an external path, we would write something like this:

```{r eval=FALSE}
dataset <- load_dataset("path_to_file")
```

### Creating filters

By default, the data extracted from gamebirds is unfiltered and can contain
unwanted entries. Therefore, we need to define filters to select only the
relevant data.
In `gblincoln`, filtering is done by creating a list of filters that associate
the name of a column from the dataset with the desired value.

For example, let's say we want to keep only birds banded between 2010 and 2020.
Banding year in the datasets is stored in the column `b.year`. Therefore to create
this filter, we would write:

```{r}
filter <- list(b.year=2010:2020) 
```
 

You might notice that `b.year` is not a column found in the original datasets
extracted from Gamebirds and was renamed by the package. If you prefer
to use the original names given by Gamebirds, it is also possible as long as the
column is present in the list of columns accepted by the package. See the
[section on column names](#column-names) for more information.
For instance, the original column name is actually `B.Year` so you
could define your filter like this and achieve the same results:

```{r}
filter_old_name <- list(B.Year=2010:2020)
```


If you want to reuse an old filter and only change one of its values or add
another filtering value, you can do so by updating the list using the
`list_update(old, new)` function that will add or replace any filter present
in `new` to the `old` list.

```{r}
# Replace the b.year filter and add the SPEC filter
filters <- list_update(filter, list(b.year=2009:2019, SPEC="ATBR"))
filters
```

Since filters will be applied in the order in which they are found, you can use
the `new_first` argument to specify if the new filters will be added at the
beginning or the end of the list. Note that all filters that are already present
will remain at the same place.


```{r}
# Replace the b.year filter and add the SPEC filter
filters2 <- list_update(filter, list(b.year=2009:2019, SPEC="ATBR"),
                            new_first=TRUE)
filters2
```


### Filter the databases
 
To apply the filters, you can then call the `filter_database()` function. Here
we use the `gb_ATBR_banding` database provided with the package as an example
(see [here](#load-data) for more information)

```{r}
ATBR_banding <- filter_database(gb_ATBR_banding, filters=filters)
```

Filtering will be done in the order in which the filter appear in the list.

#### Default filters

Note that by default, the `filter_database()` function automatically adds some
filters. This include keeping only relevant columns, type of bands,
type of birds, how the birds are recovered etc.
The complete list of default values can be found in the following object:

```{r}
DEFAULT_LINCOLN_FILTERS
```

If you want to change the value of a specific filter, just add it
in your filter list, it will automatically override the default value.
If you do not want to use the default values, you can set 
`use_default_filters=FALSE` when calling the `filter_database()` function.

Also, if you want to apply you filters before the default filters, you can
set the `filters_first` argument to `TRUE`.

For creating database specific filters, please see [this section](#database-specific-filters)

### Get direct recoveries

Once our databases are filtered, the next step is to get all the recoveries. In
practice, this is done by calling the **`get_direct_recoveries()`** function.
This function will summarize banding and recovery data to count how many of
each event happened in one year and then merge the results and compute a
recovery rate.

The `get_direct_recoveries()` function takes the banding and recoveries databases
as argument and either a list of filters with database specific filters in it,
or a list of filters for the banding data and a list of filters for the recoveries
data
([see here for more information on database specific filters](##database-specific-filters)).

```{r}
# dr_df <- get_direct_recoveries(gb_ATBR_banding, )
```


### Calculate harvest rate

### Get Lincoln estimates




### Get direct recoveries
### Calculate harvest rate from banding data (not used for estimates but for
comparison between band types)
### Estimate abundance based on harvest data

### See results


# Compare two filters
## Defining the filters
## Calculate harvest rate
## Compare and plot


## Additional information

### Extracting data from gamebirds

### Column names
GB_COLNAMES
#### Add your own column names

### Recovery year correction

### Provided datasets

All the data provided with the package
come from raw data loaded using the `load_dataset()` function.

The four (4) required datasets are provided in the packaeg. Here are the name of
the variables containing them:

 * Banding data. `gb_ATBR_banding`
 * Recovery data: `gb_ATBR_recovery`
 * Reporting_probabilities: `gb_reporting_probas`
 * Harvest data: `gb_ATBR_harvest`

This vignette uses datasets shipped with the gblincoln package. The provided
datasets are:

  * `gb_ATBR_banding`: Banding data for the ATBR species extracted from the
  Gamebirds database. This  dataset has already been cleaned using
  the `clean_dataset()` function.
  
TODO: Provide raw data to explain all steps

```{r}
# Banding data
str(gb_ATBR_banding)
# Reporting probabilities
head(gb_reporting_probas)
# Harvest data
head(gb_ATBR_harvest)
```
  

### Species locations

### Database specific filters

If columns are present in both datasets, and you desire a
different set of filters for the banding dataset and the recoveries dataset, 
we propose two methods:

 * Create two different filters, one for each dataset. For example, if we want
 to filter based on banding year but only apply it on the banding database, we
 could write:
 
```{r}
default_filter <- list(SPEC="ATBR") # Common filters that can be applied to all datasets
banding_filter <- list_update(default_filter, list(b.year=2010:2019))
recoveries_filter <- list_update(default_filter, list(r.corrected_year=2010:2019))
```

 The only problem with this approach is that you need to manipulate several objects.
 
 * Use special keywords in the filter list. It is possible to add filters used
 only on a specific type of dataset using the keywords `banding_filters`,
 `recoveries_filter`, `rho_filters` and `harvest_filters`. The following code
 would give the same result than the code described above:
 
```{r}
 
 filters <- list(SPEC="ATBR", banding_filters=list(b.year=2010:2019),
                 recoveries_filters = list(r.corrected_year=2010:2019))
 
```


If you choose to use the second method, you **MUST** specify the database type
using the `db_type` option when calling the `filter_database()` function, 
otherwise these filters will not be applied. Please refer to the help page of
the function for accepted values of `db_type`.


```{r}
filtered_db <- filter_database(gb_ATBR_banding, filters=filters, db_type="b")
```

Also note that filters defined using special database keywords will override
every other existing filters present. Therefore special care must be taken
when updating a filter list containing these filters.

For instance, let's say we want to create a filter based on the `filters` object 
we defined earlier where we want to filter the banding years for all datasets.

The method below will not work for the banding dataset. This is because
a `b.year` filter exists in the `banding_filters` option. Therefore, this value
will be used for the banding dataset.

```{r}
list_update(filters, list(b.year=2015:2019))
```

This is the way to do it:
```{r}
list_update(filters, list(
  b.year = 2015:2019,
  banding_filters = list(b.year = 2015:2019)
))
```

In this case, it might be better to create separate filters for each database.


### Gamebirds banding

### Gamebirds recoveries

### Reporting probability
Say that a version is available in the package

### Harvest data
Depends on the species
